"""
This module provides special functionality for
handling configuration options in a centralized
manner.

It provides an easy to configure way to set up
an elaborate, automatically handled command
line interface
"""

from __future__ import annotations

##############################################################################
##############################################################################
# Imports
##############################################################################

import copy
import graphlib
import importlib
import json
import typing

import fastapi
import requests
import uvicorn

from dl_manager.config.constraints import Constraint
from dl_manager.config.core import IllegalNamespace, ConfigFactory, Config
from dl_manager.config.parsing import ArgumentListParser, HyperArgumentListParser
from . import db_util
from . import logger
from . import checkpointing

log = logger.get_logger("App Builder")


##############################################################################
##############################################################################
# Web API builder
##############################################################################


class WebApp:
    def __init__(self, filename: str):
        self._app = fastapi.FastAPI()
        self._router = fastapi.APIRouter()
        self._callbacks = {}
        self._setup_callbacks = []
        self._constraints = []
        self._endpoints = {}
        self._config_factory = ConfigFactory()
        self._register_system_properties()
        with open(filename) as file:
            self._spec = json.load(file)
        self._build_endpoints(copy.deepcopy(self._spec)["commands"])
        self._add_static_endpoints()

    def _register_system_properties(self):
        self._config_factory.register_namespace("system.storage")
        self._config_factory.register_namespace("system.security")
        self._config_factory.register_namespace("system.os")
        self._config_factory.register_namespace("system.resources")
        self._config_factory.register_namespace("system.management")

        # Variable for tracking the amount of available threads
        self._config_factory.register("system.resources.threads")

        # Database credentials
        # self._config_factory.register('system.security.db-username')
        # self._config_factory.register('system.security.db-password')
        self._config_factory.register("system.security.db-token")

        # Control of self-signed certificates
        self._config_factory.register("system.security.allow-self-signed-certificates")

        # Database connection
        self._config_factory.register("system.storage.database-url")
        self._config_factory.register("system.storage.database-api")

        # Model Saving Support
        # - system.storage.generators
        #       A list of filenames pointing to the files containing
        #       the configurations for the trained feature generators.
        # - system.storage.auxiliary
        #       A list of filenames containing auxiliary files which
        #       must be included in the folder for saving a
        #       pretrained model.
        # - system.storage.auxiliary_map
        #       A mapping which is necessary to resolve filenames
        #       when loading a pretrained model.
        #       It maps "local" filenames to the actual location
        #       in the folder containing the pretrained model.
        # - system.storage.file_prefix
        #       A prefix which _should_ be used for all files
        #       generated by the pipeline, which is often
        #       forgotten about in practice.
        self._config_factory.register("system.storage.generators")
        self._config_factory.register("system.storage.auxiliary")
        self._config_factory.register("system.storage.auxiliary_map")
        self._config_factory.register("system.storage.file_prefix")

        # Current system state
        self._config_factory.register("system.management.active-command")
        self._config_factory.register("system.management.app")

        # Target home and data directories.
        self._config_factory.register("system.os.peregrine")
        self._config_factory.register("system.os.home-directory")
        self._config_factory.register("system.os.data-directory")
        self._config_factory.register("system.os.scratch-directory")

    def _build_endpoints(self, commands):
        for command in commands:
            self._build_endpoint(command)

    def _build_endpoint(self, spec):
        endpoint = _Endpoint(spec, self._config_factory, self.dispatch)
        if not endpoint.private:
            self._router.post("/" + endpoint.name, description=endpoint.description)(
                endpoint.invoke
            )
        self._endpoints[endpoint.name] = endpoint

        self._router.get(
            '/' + endpoint.name + '/dynamic-enums',
            description=f'Options for dynamic enums used in /{endpoint.name} endpoint'
        )(endpoint.get_dynamic_enum_options)

    def _add_static_endpoints(self):
        @self._router.get("/endpoints")
        async def get_endpoints():
            return self._spec

        @self._router.get('/constraints')
        async def get_constraints():
            constraints = []
            for obj in self._constraints:
                for c in obj.to_json():
                    constraints.append(c)
            return constraints

        for cmd in self._spec["commands"]:
            for arg in cmd["args"]:
                if arg["type"] != "arglist":
                    continue
                self._add_arglist_endpoint(cmd["name"], arg)

    def _add_arglist_endpoint(self, cmd_name, spec):
        @self._router.get(f'/arglists/{cmd_name}/{spec["name"]}')
        async def get_arglist():
            module, item = spec["options"][0]["map-path"].rsplit(".", maxsplit=1)
            mapping = getattr(importlib.import_module(module), item)
            payload = {
                name: [arg.get_json_spec() for arg in cls.get_arguments().values()]
                for name, cls in mapping.items()
            }
            return payload

    def register_callback(self, event, func):
        self._callbacks[event] = func

    def register_setup_callback(self, func):
        self._setup_callbacks.append(func)

    def add_constraint(self, c: Constraint):
        self._constraints.append(c)

    def deploy(self, port, keyfile, certfile):
        self._app.include_router(self._router)
        uvicorn.run(
            self._app,
            host="0.0.0.0",
            port=port,
            ssl_keyfile=keyfile,
            ssl_certfile=certfile,
        )

    def execute_script(self, filename, *, invalidate_checkpoints):
        manager = checkpointing.CheckpointManager(filename)
        if invalidate_checkpoints:
            manager.invalidate()
        token = manager.get_auth()["token"]
        for command in manager.commands():
            # Refresh the token
            response = requests.post(
                url=manager.get_auth()["token-endpoint"],
                headers={"Authorization": "Bearer " + token},
            )
            response.raise_for_status()
            token = response.json()["access_token"]
            # Call the endpoint internally
            endpoint = command["cmd"]
            payload = {"auth": {"token": token}, "config": command["args"]}
            self._endpoints[endpoint].invoke_with_json(payload)

    def invoke_endpoint(self, name: str, conf: Config, payload):
        return self._endpoints[name].run(conf, payload)

    def dispatch(self, name, conf: Config):
        for keys, predicate, message in self._constraints:
            try:
                values = [(conf.get(key) if key != "#config" else conf) for key in keys]
            except IllegalNamespace:
                continue  # Constraint not relevant
            if not predicate(*values):
                error = f'Constraint check on {",".join(keys)} failed: {message}'
                raise fastapi.HTTPException(detail=error, status_code=400)
        conf.set("system.management.active-command", name)
        conf.set("system.management.app", self)
        for callback in self._setup_callbacks:
            callback(conf)
        return self._callbacks[name](conf)

    def new_config(self, *namespaces) -> Config:
        return self._config_factory.build_config(*namespaces)


class _Endpoint:

    def __init__(self, spec, config_factory: ConfigFactory, callback):
        self.name = spec["name"]
        log.info(f"Registering endpoint {self.name!r}")
        self.description = spec["help"]
        self._args = spec["args"]
        self.private = spec["private"]
        validators = [_ArgumentValidator(arg) for arg in self._args]
        self._validators = {arg.name: arg for arg in validators}
        self._dyn_enums = {val.name: val.get_dynamic_enum_options()
                           for val in validators
                           if val.dtype == 'dynamic_enum'}
        for v in self._validators.values():
            if v.depends is None:
                continue
            if v.depends not in self._validators:
                raise ValueError(
                    f"[{self.name}] Argument {v.name!r} depends on unknown argument {v.depends!r}"
                )
            # if self._validators[v.depends].dtype != 'bool':
            #    raise ValueError(f'[{self.name}] Argument {v.name!r} depends on non-Boolean argument {v.depends!r}')
        self._order = []
        self._compute_validation_order()
        self._required = {arg.name for arg in validators if arg.required}
        self._defaults = {
            arg.name: arg.default
            for arg in validators
            if arg.default is not _ArgumentValidator.NOT_SET
        }
        self._config_factory = config_factory
        self._dispatcher = callback
        self._config_factory.register_namespace(self.name)
        for v in self._validators:
            self._config_factory.register(f"{self.name}.{v}")

    def _compute_validation_order(self):
        sorter = graphlib.TopologicalSorter()
        for v in self._validators.values():
            if v.depends is not None:
                sorter.add(v.name, v.depends)
            else:
                sorter.add(v.name)
        try:
            self._order = list(sorter.static_order())
        except graphlib.CycleError:
            raise ValueError(
                f"[{self.name}] Cycle in if_null/unless_null declarations."
            )

    async def invoke(self, req: fastapi.Request):
        if self.private:
            fastapi.HTTPException(
                detail=f"Endpoint {self.name} is private/internal", status_code=406
            )
        payload = await req.json()
        return self.invoke_with_json(payload)

    async def get_dynamic_enum_options(self):
        return self._dyn_enums

    def invoke_with_json(self, payload):
        conf = self._config_factory.build_config(self.name, "system")
        if "auth" in payload:
            auth = payload["auth"]
            # conf.set('system.security.db-username', auth['username'])
            # conf.set('system.security.db-password', auth['password'])
            conf.set("system.security.db-token", auth["token"])
        return self.run(conf, payload["config"])

    def run(self, conf: Config, payload):
        args = self.validate(payload)
        for name, value in args.items():
            conf.set(f"{self.name}.{name}", value)
        return self._dispatcher(self.name, conf)

    def validate(self, obj):
        return self._validate(obj)

    def _validate(self, obj):
        if not isinstance(obj, dict):
            raise fastapi.HTTPException(
                detail="Expected a JSON object", status_code=400
            )
        parsed = {}
        not_handled = set(obj)
        for name in self._order:
            try:
                value = obj[name]
            except KeyError:
                if name in self._defaults:
                    value = self._defaults[name]
                else:
                    continue
            if name not in self._validators:
                raise fastapi.HTTPException(
                    status_code=400,
                    detail=f"Invalid argument for endpoint {self.name!r}: {name}",
                )
            validator = self._validators[name]
            if validator.depends is not None:
                parsed[name] = validator.validate_conditionally(
                    value, parsed[validator.depends]
                )
            else:
                parsed[name] = validator.validate(value)
            if name in not_handled:
                not_handled.remove(name)
        missing = self._required - set(parsed.keys())
        if missing:
            raise fastapi.HTTPException(
                status_code=400,
                detail=f'Endpoint {self.name!r} is missing the following required arguments: {", ".join(missing)}',
            )
        if not_handled:
            raise fastapi.HTTPException(
                status_code=400,
                detail=f'Endpoint {self.name!r} received unknown arguments: {", ".join(not_handled)}',
            )
        # for name in set(self._defaults) - set(parsed):
        #    val = self._validators[name]
        #    if val.depends is not None:
        #        parsed[name] = val.validate_conditionally(value, parsed[validator.depends])
        #    else:
        #        parsed[name] = self._validators[name].validate(self._defaults[name])
        return parsed


class _ArgumentValidator:
    NOT_SET = object()

    def __init__(self, spec):
        self.name = spec["name"]
        log.info(f"Registering argument {self.name!r}")
        self.description = spec["help"]
        self.required = spec.get("required", False)
        self.default = spec.get("default", self.NOT_SET)
        self._nargs = "1" if "nargs" not in spec else spec["nargs"]
        self._type = spec["type"]
        self._null_if = spec.get("null-if", None)
        if self._null_if is not None:
            if not isinstance(self._null_if, dict):
                raise ValueError(f'[{self.name}] "null-if" value must be a dict')
            if "name" not in self._null_if or "value" not in self._null_if:
                raise ValueError(
                    f'[{self.name}] "null-if" must have keys "name" and "value"'
                )
        self._null_unless = spec.get("null-unless", None)
        if self._null_unless is not None:
            if not isinstance(self._null_unless, dict):
                raise ValueError(f'[{self.name}] "null-unless" value must be a dict')
            if "name" not in self._null_unless or "value" not in self._null_unless:
                raise ValueError(
                    f'[{self.name}] "null-unless" must have keys "name" and "value"'
                )
        if self._null_if is not None and self._null_unless is not None:
            raise ValueError(
                f'[{self.name}] Cannot set both "null-if" and "null-unless"'
            )
        # self._options = spec.get('options', [])
        self._options: typing.Any = spec["options"]
        if self._nargs not in ("1", "*", "+"):
            raise ValueError(f"[{self.name}] Invalid nargs: {self._nargs}")
        if self._type not in (
            "str",
            "int",
            "bool",
            "enum",
            "class",
            "arglist",
            "float",
            "query",
            "dynamic_enum",
            "object",
            "hyper_arglist",
        ):
            raise ValueError(f"[{self.name}] Invalid type: {self._type}")
        if self._type == "class":
            if len(self._options) != 1:
                raise ValueError(
                    f'[{self.name}] Argument of type "class" requires exactly one option.'
                )
            dotted_name = self._options[0]
            module, item = dotted_name.rsplit(".", maxsplit=1)
            mod = importlib.import_module(module)
            cls = getattr(mod, item)
            self._options = [cls]
        if self._type == "arglist":
            if len(self._options) != 1 or not isinstance(self._options[0], dict):
                raise ValueError(
                    f'[{self.name}] Argument of type "arglist" requires exactly one option of type "dict".'
                )
            if (
                "map-path" not in self._options[0]
                or "multi-valued" not in self._options[0]
            ):
                raise ValueError(
                    f'[{self.name}] Option of "arglist" argument must contain "map-path" and "multi-valued".'
                )
            module, item = self._options[0]["map-path"].rsplit(".", maxsplit=1) # type: ignore
            self._options[0] = ArgumentListParser(
                name=self.name,
                lookup_map=getattr(importlib.import_module(module), item),
                multi_valued=self._options[0]["multi-valued"],  # type: ignore
            )
        if self._type == "hyper_arglist":
            if len(self._options) != 1 or not isinstance(self._options[0], dict):
                raise ValueError(
                    f'[{self.name}] Argument of type "hyper_arglist" requires exactly one option of type "dict".'
                )
            if (
                "map-path" not in self._options[0]
                or "multi-valued" not in self._options[0]
            ):
                raise ValueError(
                    f'[{self.name}] Option of "hyper_arglist" argument must contain "map-path" and "multi-valued".'
                )
            module, item = self._options[0]["map-path"].rsplit(".", maxsplit=1) # type: ignore
            self._options[0] = HyperArgumentListParser(
                name=self.name,
                lookup_map=getattr(importlib.import_module(module), item),
                multi_valued=self._options[0]["multi-valued"], # type: ignore
            )
        if self._type == "dynamic_enum":
            if len(self._options) != 1 or not isinstance(self._options[0], str):
                raise ValueError(
                    f'[{self.name}] Argument of type "dynamic_enum" requires exactly one option of type "str".'
                )
            module, item = self._options[0].rsplit(".", maxsplit=1) # type: ignore
            self._options[0] = set(getattr(importlib.import_module(module), item))

    def get_dynamic_enum_options(self):
        if self._type != 'dynamic_enum':
            raise ValueError('Not a dynamic enum')
        return self._options[0]

    @property
    def depends(self):
        if self._null_if:
            return self._null_if["name"]
        if self._null_unless:
            return self._null_unless["name"]
        return None

    @property
    def dtype(self):
        return self._type

    def validate_conditionally(self, value, flag):
        if self._null_if and self._null_if["value"] == flag:
            if value is not None:
                raise fastapi.HTTPException(
                    detail=f'Argument {self.name!r} must be null because {self.depends!r} == {self._null_if["value"]}',
                    status_code=400,
                )
            return None
        elif self._null_if and self._null_if["value"] != flag:
            return self.validate(value)
        elif self._null_unless and self._null_unless["value"] == flag:
            return self.validate(value)
        else:
            if value is not None:
                raise fastapi.HTTPException(
                    detail=f'Argument {self.name!r} must be null because {self.depends!r} != {self._null_unless["value"]}',
                    status_code=400,
                )
            return None

    def validate(self, value):
        if self._nargs == "1":
            return self._validate(value)
        else:
            if not isinstance(value, list):
                raise fastapi.HTTPException(
                    detail=f"{self.name!r} is a multi-valued argument. Expected a list. (got {value})",
                    status_code=400,
                )
            if self._nargs == "+" and not value:
                raise fastapi.HTTPException(
                    detail=f"{self.name!r} requires at least 1 value.", status_code=400
                )
            return [self._validate(x) for x in value]

    def _validate(self, x):
        match self._type:
            case "str":
                if not isinstance(x, str):
                    self._raise_invalid_type("string", x)
                return x
            case "int":
                if not isinstance(x, int):
                    self._raise_invalid_type("int", x)
                return x
            case "bool":
                if not isinstance(x, bool) and (
                    not isinstance(x, int) or x not in (0, 1)
                ):
                    self._raise_invalid_type("bool", x)
                return x
            case "float":
                if not isinstance(x, float):
                    self._raise_invalid_type("float", x)
                return x
            case "enum":
                if not isinstance(x, str):
                    raise fastapi.HTTPException(
                        detail=f"{self.name!r} enum argument must be of type string, got {x.__class__.__name__}",
                        status_code=400,
                    )
                if x not in self._options:
                    raise fastapi.HTTPException(
                        detail=f"Invalid option for {self.name!r}: {x} (valid options: {self._options})",
                        status_code=400,
                    )
                return x
            case "class":
                try:
                    return self._options[0](x)  # type: ignore
                except Exception as e:
                    raise fastapi.HTTPException(
                        detail=f"Error while converting {self.name!r} to {self._options[0].__class__.__name__}: {e}",
                        status_code=400,
                    )
            case "query":
                try:
                    return db_util.json_to_query(x)
                except Exception as e:
                    raise fastapi.HTTPException(
                        detail=f"Invalid query for param {self.name!r}: {x} ({e})",
                        status_code=400,
                    )
            case "arglist":
                return self._options[0].validate(x)
            case "hyper_arglist":
                return self._options[0].validate(x)
            case "dynamic_enum":
                if not isinstance(x, str):
                    raise fastapi.HTTPException(
                        detail=f"{self.name!r} dynamic_enum argument must be of type string, got {x.__class__.__name__}",
                        status_code=400,
                    )
                if x not in self._options[0]:
                    raise fastapi.HTTPException(
                        detail=f"Invalid option for {self.name!r}: {x} (valid options: {self._options})",
                        status_code=400,
                    )
                return x
            case "object":
                return x

    def _raise_invalid_type(self, expected, got):
        raise fastapi.HTTPException(
            detail=f"{self.name!r} must be of type {expected}, got {got.__class__.__name__}",
            status_code=400,
        )


##############################################################################
##############################################################################
# Constraint System
##############################################################################


def _fmt_list(x):
    *rest, last = x
    return ', '.join(rest) + ' and ' + last



